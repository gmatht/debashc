use crate::ast::{Command, SimpleCommand, Pipeline, IfStatement, WhileLoop, ForLoop, Function, Block};

pub struct LuaGenerator {
    indent_level: usize,
}

impl LuaGenerator {
    pub fn new() -> Self {
        Self { indent_level: 0 }
    }

    pub fn generate(&mut self, commands: &[Command]) -> String {
        let mut lua_code = String::new();
        
        // Add Lua-specific header
        lua_code.push_str("#!/usr/bin/env lua\n");
        lua_code.push_str("-- Generated by debashc\n\n");
        
        // Add lfs fallback for LuaFileSystem
        lua_code.push_str("-- LuaFileSystem fallback\n");
        lua_code.push_str("local lfs_ok, lfs = pcall(require, 'lfs')\n");
        lua_code.push_str("if not lfs_ok then\n");
        lua_code.push_str("    lfs = {}\n");
        lua_code.push_str("    function lfs.dir(path)\n");
        lua_code.push_str("        local handle = io.popen('ls -1 ' .. path)\n");
        lua_code.push_str("        local result = {}\n");
        lua_code.push_str("        for line in handle:lines() do\n");
        lua_code.push_str("            table.insert(result, line)\n");
        lua_code.push_str("        end\n");
        lua_code.push_str("        handle:close()\n");
        lua_code.push_str("        return result\n");
        lua_code.push_str("    end\n");
        lua_code.push_str("    function lfs.mkdir(path)\n");
        lua_code.push_str("        os.execute('mkdir -p ' .. path)\n");
        lua_code.push_str("    end\n");
        lua_code.push_str("    function lfs.attributes(path)\n");
        lua_code.push_str("        local handle = io.popen('stat ' .. path .. ' 2>/dev/null')\n");
        lua_code.push_str("        local result = handle:read('*all')\n");
        lua_code.push_str("        handle:close()\n");
        lua_code.push_str("        return result ~= ''\n");
        lua_code.push_str("    end\n");
        lua_code.push_str("end\n\n");

        for command in commands {
            let command_code = self.generate_command(command);
            lua_code.push_str(&command_code);
            
            // Add newline if the command doesn't already end with one
            if !command_code.ends_with('\n') {
                lua_code.push('\n');
            }
        }

        lua_code
    }

    fn generate_command(&mut self, command: &Command) -> String {
        match command {
            Command::Simple(cmd) => self.generate_simple_command(cmd),
            Command::Pipeline(pipeline) => self.generate_pipeline(pipeline),
            Command::If(if_stmt) => self.generate_if_statement(if_stmt),
            Command::While(while_loop) => self.generate_while_loop(while_loop),
            Command::For(for_loop) => self.generate_for_loop(for_loop),
            Command::Function(func) => self.generate_function(func),
            Command::Subshell(cmd) => self.generate_subshell(cmd),
            Command::Background(cmd) => self.generate_background(cmd),
            Command::Block(block) => self.generate_block(block),
        }
    }

    fn generate_simple_command(&mut self, cmd: &SimpleCommand) -> String {
        let mut lua_code = String::new();
        
        // Handle environment variables
        for (key, value) in &cmd.env_vars {
            lua_code.push_str(&format!("os.setenv('{}', '{}')\n", key, value));
        }

        match cmd.name.as_str() {
            "echo" => {
                if let Some(arg) = cmd.args.first() {
                    lua_code.push_str(&format!("print({})\n", self.escape_lua_string(arg)));
                } else {
                    lua_code.push_str("print()\n");
                }
            }
            "sleep" => {
                if let Some(arg) = cmd.args.first() {
                    // Use socket.sleep if available, fallback to os.execute
                    lua_code.push_str("local has_socket, socket = pcall(require, 'socket')\n");
                    lua_code.push_str("if has_socket then\n");
                    lua_code.push_str(&format!("    socket.sleep({})\n", arg));
                    lua_code.push_str("else\n");
                    lua_code.push_str(&format!("    os.execute('sleep {}')\n", arg.replace("'", "\\'")));
                    lua_code.push_str("end\n");
                }
            }
            "cd" => {
                if let Some(arg) = cmd.args.first() {
                    lua_code.push_str(&format!("os.execute('cd {}')\n", arg.replace("'", "\\'")));
                }
            }
            "ls" => {
                if cmd.args.is_empty() {
                    lua_code.push_str("for file in ipairs(lfs.dir('.')) do\n");
                    lua_code.push_str("    print(file)\n");
                    lua_code.push_str("end\n");
                } else {
                    let args = cmd.args.iter().map(|arg| arg.replace("'", "\\'")).collect::<Vec<_>>().join(" ");
                    lua_code.push_str(&format!("os.execute('ls {}\n", args));
                }
            }
            "grep" => {
                if cmd.args.len() >= 2 {
                    let pattern = &cmd.args[0];
                    let file = &cmd.args[1];
                    lua_code.push_str(&format!("os.execute('grep {} {}\n", 
                        pattern.replace("'", "\\'"), 
                        file.replace("'", "\\'")));
                }
            }
            "cat" => {
                if let Some(file) = cmd.args.first() {
                    lua_code.push_str(&format!("local f = io.open('{}', 'r')\n", file.replace("'", "\\'")));
                    lua_code.push_str("if f then\n");
                    lua_code.push_str("    print(f:read('*all'))\n");
                    lua_code.push_str("    f:close()\n");
                    lua_code.push_str("end\n");
                }
            }
            "mkdir" => {
                if let Some(dir) = cmd.args.first() {
                    lua_code.push_str(&format!("lfs.mkdir('{}')\n", dir.replace("'", "\\'")));
                }
            }
            "rm" => {
                if let Some(file) = cmd.args.first() {
                    lua_code.push_str(&format!("os.remove('{}')\n", file.replace("'", "\\'")));
                }
            }
            "mv" => {
                if cmd.args.len() >= 2 {
                    let src = &cmd.args[0];
                    let dst = &cmd.args[1];
                    lua_code.push_str(&format!("os.rename('{}', '{}')\n", 
                        src.replace("'", "\\'"), 
                        dst.replace("'", "\\'")));
                }
            }
            "cp" => {
                if cmd.args.len() >= 2 {
                    let src = &cmd.args[0];
                    let dst = &cmd.args[1];
                    lua_code.push_str(&format!("os.execute('cp {} {}')\n", 
                        src.replace("'", "\\'"), 
                        dst.replace("'", "\\'")));
                }
            }
            _ => {
                // Generic command
                let args = cmd.args.iter().map(|arg| arg.replace("'", "\\'")).collect::<Vec<_>>().join(" ");
                lua_code.push_str(&format!("os.execute('{} {}')\n", cmd.name, args));
            }
        }

        lua_code
    }

    fn generate_pipeline(&mut self, pipeline: &Pipeline) -> String {
        let mut lua_code = String::new();
        
        // For now, just execute the first command
        // In a more complete implementation, we'd handle pipes
        if let Some(first_cmd) = pipeline.commands.first() {
            lua_code.push_str(&self.generate_command(first_cmd));
        }
        
        lua_code
    }

    fn generate_if_statement(&mut self, if_stmt: &IfStatement) -> String {
        let mut lua_code = String::new();
        
        lua_code.push_str("if ");
        lua_code.push_str(&self.convert_condition_to_lua(&if_stmt.condition));
        lua_code.push_str(" then\n");
        
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(&if_stmt.then_branch));
        self.indent_level -= 1;
        
        if let Some(else_branch) = &if_stmt.else_branch {
            lua_code.push_str("else\n");
            self.indent_level += 1;
            lua_code.push_str(&self.generate_command(else_branch));
            self.indent_level -= 1;
        }
        
        lua_code.push_str("end\n");
        lua_code
    }

    fn generate_while_loop(&mut self, while_loop: &WhileLoop) -> String {
        let mut lua_code = String::new();
        
        lua_code.push_str("while ");
        lua_code.push_str(&self.convert_condition_to_lua(&while_loop.condition));
        lua_code.push_str(" do\n");
        
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(&while_loop.body));
        self.indent_level -= 1;
        
        lua_code.push_str("end\n");
        lua_code
    }

    fn generate_for_loop(&mut self, for_loop: &ForLoop) -> String {
        let mut lua_code = String::new();
        
        lua_code.push_str(&format!("for {} in ipairs({{{}}}) do\n", 
            for_loop.variable, 
            for_loop.items.join(", ")));
        
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(&for_loop.body));
        self.indent_level -= 1;
        
        lua_code.push_str("end\n");
        lua_code
    }

    fn generate_function(&mut self, func: &Function) -> String {
        let mut lua_code = String::new();
        
        lua_code.push_str(&format!("function {}(...)\n", func.name));
        
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(&func.body));
        self.indent_level -= 1;
        
        lua_code.push_str("end\n");
        lua_code
    }

    fn generate_subshell(&mut self, cmd: &Command) -> String {
        let mut lua_code = String::new();
        // Run subshell inline
        lua_code.push_str("do\n");
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(cmd));
        self.indent_level -= 1;
        lua_code.push_str("end\n");
        lua_code
    }

    fn generate_background(&mut self, cmd: &Command) -> String {
        let mut lua_code = String::new();
        // Background: use coroutine to emulate async
        lua_code.push_str("local co = coroutine.create(function()\n");
        self.indent_level += 1;
        lua_code.push_str(&self.generate_command(cmd));
        self.indent_level -= 1;
        lua_code.push_str("end)\n");
        lua_code.push_str("coroutine.resume(co)\n");
        lua_code
    }

    fn generate_block(&mut self, block: &Block) -> String {
        let mut lua_code = String::new();
        for cmd in &block.commands {
            lua_code.push_str(&self.generate_command(cmd));
        }
        lua_code
    }

    fn convert_condition_to_lua(&self, condition: &Command) -> String {
        match condition {
            Command::Simple(cmd) => {
                if cmd.name == "test" || cmd.name == "[" {
                    if let Some(arg) = cmd.args.first() {
                        match arg.as_str() {
                            "-f" => {
                                if let Some(file) = cmd.args.get(1) {
                                    return format!("lfs.attributes('{}')", file.replace("'", "\\'"));
                                }
                            }
                            "-d" => {
                                if let Some(dir) = cmd.args.get(1) {
                                    return format!("lfs.attributes('{}')", dir.replace("'", "\\'"));
                                }
                            }
                            "-e" => {
                                if let Some(path) = cmd.args.get(1) {
                                    return format!("lfs.attributes('{}')", path.replace("'", "\\'"));
                                }
                            }
                            _ => {}
                        }
                    }
                }
                "true".to_string()
            }
            _ => "true".to_string(),
        }
    }

    fn escape_lua_string(&self, s: &str) -> String {
        if s.contains('"') && s.contains("'") {
            // Use double brackets for strings with both quotes
            format!("[[{}]]", s)
        } else if s.contains('"') {
            // Use single quotes if string contains double quotes
            format!("'{}'", s.replace("'", "\\'"))
        } else {
            // Use double quotes otherwise
            format!("\"{}\"", s.replace("\"", "\\\""))
        }
    }
}
